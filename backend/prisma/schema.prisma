generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String              @id @default(uuid())
  email            String              @unique
  passwordHash     String
  username         String
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt
  role             UserRole            @default(USER)
  anomalyFlags     AnomalyFlag[]
  records          AnswerRecord[]
  habitProfile     HabitProfile?
  learningPlan     LearningPlan?
  learningSessions LearningSession[]
  rewardQueues     RewardQueue[]
  sessions         Session[]
  badges           UserBadge[]
  stateHistory     UserStateHistory[]
  studyConfig      UserStudyConfig?
  wordBooks        WordBook[]
  learningStates   WordLearningState[]
  wordScores       WordScore[]

  @@map("users")
}

model WordBook {
  id          String       @id @default(uuid())
  name        String
  description String?
  type        WordBookType
  userId      String?
  isPublic    Boolean      @default(false)
  wordCount   Int          @default(0)
  coverImage  String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  user        User?        @relation(fields: [userId], references: [id], onDelete: Cascade)
  words       Word[]

  @@index([userId])
  @@index([type])
  @@map("word_books")
}

model Word {
  id             String              @id @default(uuid())
  spelling       String
  phonetic       String
  meanings       String[]
  examples       String[]
  audioUrl       String?
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt
  wordBookId     String
  anomalyFlags   AnomalyFlag[]
  records        AnswerRecord[]
  learningStates WordLearningState[]
  wordScores     WordScore[]
  wordBook       WordBook            @relation(fields: [wordBookId], references: [id], onDelete: Cascade)

  @@unique([wordBookId, spelling], name: "unique_spelling_per_book")
  @@index([wordBookId])
  @@index([spelling])
  @@index([wordBookId, createdAt])
  @@map("words")
}

model AnswerRecord {
  id                 String           @id @default(uuid())
  userId             String
  wordId             String
  selectedAnswer     String
  correctAnswer      String
  isCorrect          Boolean
  timestamp          DateTime         @default(now())
  dwellTime          Int?
  masteryLevelAfter  Int?
  masteryLevelBefore Int?
  responseTime       Int?
  sessionId          String?
  session            LearningSession? @relation(fields: [sessionId], references: [id])
  user               User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  word               Word             @relation(fields: [wordId], references: [id], onDelete: Cascade)

  @@unique([userId, wordId, timestamp], name: "unique_user_word_timestamp")
  @@index([userId])
  @@index([wordId])
  @@index([sessionId])
  @@index([userId, timestamp])
  @@index([wordId, timestamp])
  @@index([userId, isCorrect])
  @@index([sessionId, timestamp])
  @@map("answer_records")
}

model Session {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("sessions")
}

model UserStudyConfig {
  id                  String   @id @default(uuid())
  userId              String   @unique
  selectedWordBookIds String[]
  dailyWordCount      Int      @default(20)
  studyMode           String   @default("sequential")
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_study_configs")
}

model WordLearningState {
  id                 String    @id @default(uuid())
  userId             String
  wordId             String
  state              WordState @default(NEW)
  masteryLevel       Int       @default(0)
  easeFactor         Float     @default(2.5)
  reviewCount        Int       @default(0)
  lastReviewDate     DateTime?
  nextReviewDate     DateTime?
  currentInterval    Int       @default(1)
  consecutiveCorrect Int       @default(0)
  consecutiveWrong   Int       @default(0)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  user               User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  word               Word      @relation(fields: [wordId], references: [id], onDelete: Cascade)

  @@unique([userId, wordId], name: "unique_user_word")
  @@index([userId])
  @@index([wordId])
  @@index([state])
  @@index([nextReviewDate])
  @@index([userId, state])
  @@index([userId, masteryLevel])
  @@index([userId, nextReviewDate])
  @@map("word_learning_states")
}

model WordScore {
  id                  String   @id @default(uuid())
  userId              String
  wordId              String
  totalScore          Float    @default(0)
  accuracyScore       Float    @default(0)
  speedScore          Float    @default(0)
  stabilityScore      Float    @default(0)
  proficiencyScore    Float    @default(0)
  totalAttempts       Int      @default(0)
  correctAttempts     Int      @default(0)
  averageResponseTime Float    @default(0)
  averageDwellTime    Float    @default(0)
  recentAccuracy      Float    @default(0)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  word                Word     @relation(fields: [wordId], references: [id], onDelete: Cascade)

  @@unique([userId, wordId], name: "unique_user_word_score")
  @@index([userId])
  @@index([wordId])
  @@index([totalScore])
  @@index([userId, totalScore])
  @@map("word_scores")
}

model AlgorithmConfig {
  id                                String          @id @default(uuid())
  name                              String          @unique
  description                       String?
  reviewIntervals                   Int[]
  consecutiveCorrectThreshold       Int             @default(5)
  consecutiveWrongThreshold         Int             @default(3)
  difficultyAdjustmentInterval      Int             @default(1)
  priorityWeightNewWord             Int             @default(40)
  priorityWeightErrorRate           Int             @default(30)
  priorityWeightOverdueTime         Int             @default(20)
  priorityWeightWordScore           Int             @default(10)
  scoreWeightAccuracy               Int             @default(40)
  scoreWeightSpeed                  Int             @default(30)
  scoreWeightStability              Int             @default(20)
  scoreWeightProficiency            Int             @default(10)
  speedThresholdExcellent           Int             @default(3000)
  speedThresholdGood                Int             @default(5000)
  speedThresholdAverage             Int             @default(10000)
  speedThresholdSlow                Int             @default(10000)
  newWordRatioDefault               Float           @default(0.3)
  newWordRatioHighAccuracy          Float           @default(0.5)
  newWordRatioLowAccuracy           Float           @default(0.1)
  newWordRatioHighAccuracyThreshold Float           @default(0.85)
  newWordRatioLowAccuracyThreshold  Float           @default(0.65)
  masteryThresholds                 Json
  isDefault                         Boolean         @default(false)
  createdAt                         DateTime        @default(now())
  updatedAt                         DateTime        @updatedAt
  createdBy                         String?
  configHistory                     ConfigHistory[]

  @@map("algorithm_configs")
}

model ConfigHistory {
  id            String          @id @default(uuid())
  configId      String
  changedBy     String
  changeReason  String?
  previousValue Json
  newValue      Json
  timestamp     DateTime        @default(now())
  config        AlgorithmConfig @relation(fields: [configId], references: [id], onDelete: Cascade)

  @@index([configId])
  @@index([changedBy])
  @@index([timestamp])
  @@map("config_history")
}

model AnomalyFlag {
  id         String    @id @default(uuid())
  userId     String
  wordId     String
  flaggedBy  String
  reason     String
  flaggedAt  DateTime  @default(now())
  resolved   Boolean   @default(false)
  resolvedAt DateTime?
  resolvedBy String?
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  word       Word      @relation(fields: [wordId], references: [id], onDelete: Cascade)

  @@unique([userId, wordId])
  @@index([userId])
  @@index([wordId])
  @@index([flaggedAt])
  @@map("anomaly_flags")
}

model AmasUserState {
  id               String   @id @default(uuid())
  userId           String   @unique
  attention        Float    @default(0.7)
  fatigue          Float    @default(0)
  motivation       Float    @default(0)
  confidence       Float    @default(0.5)
  cognitiveProfile Json     @default("{\"mem\": 0.5, \"speed\": 0.5, \"stability\": 0.5}")
  habitProfile     Json?
  trendState       String?
  lastUpdateTs     BigInt   @default(0)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([userId])
  @@index([lastUpdateTs])
  @@map("amas_user_states")
}

model AmasUserModel {
  id        String   @id @default(uuid())
  userId    String   @unique
  modelData Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("amas_user_models")
}

model LearningSession {
  id             String          @id @default(uuid())
  userId         String
  startedAt      DateTime        @default(now())
  endedAt        DateTime?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  answerRecords  AnswerRecord[]
  featureVectors FeatureVector[]
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  rewardQueues   RewardQueue[]

  @@index([userId, startedAt])
  @@map("learning_sessions")
}

model FeatureVector {
  sessionId      String
  featureVersion Int
  features       Json
  normMethod     String?
  createdAt      DateTime        @default(now())
  session        LearningSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@id([sessionId, featureVersion])
  @@index([featureVersion, createdAt])
  @@map("feature_vectors")
}

model HabitProfile {
  userId     String   @id
  timePref   Json?
  rhythmPref Json?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("habit_profiles")
}

model RewardQueue {
  id             String           @id @default(uuid())
  sessionId      String?
  userId         String
  dueTs          DateTime
  reward         Float
  status         RewardStatus     @default(PENDING)
  idempotencyKey String           @unique
  lastError      String?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  session        LearningSession? @relation(fields: [sessionId], references: [id])
  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([dueTs, status])
  @@index([userId])
  @@index([sessionId])
  @@index([userId, status, dueTs])
  @@map("reward_queue")
}

model UserStateHistory {
  id         String   @id @default(uuid())
  userId     String
  date       DateTime @db.Date
  attention  Float
  fatigue    Float
  motivation Float
  memory     Float
  speed      Float
  stability  Float
  trendState String?
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@map("user_state_history")
}

model BadgeDefinition {
  id          String        @id @default(uuid())
  name        String
  description String
  iconUrl     String
  category    BadgeCategory
  tier        Int           @default(1)
  condition   Json
  createdAt   DateTime      @default(now())
  userBadges  UserBadge[]

  @@unique([name, tier])
  @@map("badge_definitions")
}

model UserBadge {
  id         String          @id @default(uuid())
  userId     String
  badgeId    String
  tier       Int             @default(1)
  unlockedAt DateTime        @default(now())
  badge      BadgeDefinition @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  user       User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId, tier])
  @@index([userId])
  @@index([badgeId])
  @@map("user_badges")
}

model LearningPlan {
  id                      String   @id @default(uuid())
  userId                  String   @unique
  dailyTarget             Int
  estimatedCompletionDate DateTime
  wordbookDistribution    Json
  weeklyMilestones        Json
  isActive                Boolean  @default(true)
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt
  totalWords              Int      @default(0)
  user                    User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("learning_plans")
}

enum UserRole {
  USER
  ADMIN
}

enum WordBookType {
  SYSTEM
  USER
}

enum WordState {
  NEW
  LEARNING
  REVIEWING
  MASTERED
}

enum RewardStatus {
  PENDING
  PROCESSING
  DONE
  FAILED
}

enum BadgeCategory {
  STREAK
  ACCURACY
  COGNITIVE
  MILESTONE
}

enum ABExperimentStatus {
  DRAFT
  RUNNING
  COMPLETED
  ABORTED
}

enum ABTrafficAllocation {
  EVEN
  WEIGHTED
  DYNAMIC
}

// ==================== A/B测试相关模型 ====================

/// A/B测试实验配置
model ABExperiment {
  id                      String               @id @default(uuid())
  name                    String
  description             String?
  trafficAllocation       ABTrafficAllocation  @default(WEIGHTED)
  minSampleSize           Int                  @default(100)
  significanceLevel       Float                @default(0.05)
  minimumDetectableEffect Float                @default(0.05)
  autoDecision            Boolean              @default(false)
  status                  ABExperimentStatus   @default(DRAFT)
  startedAt               DateTime?
  endedAt                 DateTime?
  createdAt               DateTime             @default(now())
  updatedAt               DateTime             @updatedAt

  variants    ABVariant[]
  metrics     ABExperimentMetrics[]
  assignments ABUserAssignment[]

  @@index([status])
  @@index([startedAt])
  @@map("ab_experiments")
}

/// A/B测试变体
model ABVariant {
  id           String       @id @default(uuid())
  experimentId String
  name         String
  weight       Float        @default(0.5)
  isControl    Boolean      @default(false)
  parameters   Json         @default("{}")
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  experiment  ABExperiment          @relation(fields: [experimentId], references: [id], onDelete: Cascade)
  assignments ABUserAssignment[]
  metrics     ABExperimentMetrics[]

  @@index([experimentId])
  @@map("ab_variants")
}

/// 用户变体分配（持久化）
model ABUserAssignment {
  userId       String
  experimentId String
  variantId    String
  assignedAt   DateTime @default(now())

  experiment ABExperiment @relation(fields: [experimentId], references: [id], onDelete: Cascade)
  variant    ABVariant    @relation(fields: [variantId], references: [id], onDelete: Cascade)

  @@id([userId, experimentId])
  @@index([variantId])
  @@map("ab_user_assignments")
}

/// 实验指标数据
model ABExperimentMetrics {
  id           String   @id @default(uuid())
  experimentId String
  variantId    String
  sampleCount  Int      @default(0)
  primaryMetric Float   @default(0)
  averageReward Float   @default(0)
  stdDev       Float    @default(0)
  m2           Float    @default(0) // Welford算法累积值
  updatedAt    DateTime @updatedAt

  experiment ABExperiment @relation(fields: [experimentId], references: [id], onDelete: Cascade)
  variant    ABVariant    @relation(fields: [variantId], references: [id], onDelete: Cascade)

  @@unique([experimentId, variantId])
  @@map("ab_experiment_metrics")
}

// ==================== 优化器相关模型 ====================

/// 贝叶斯优化器状态持久化
model BayesianOptimizerState {
  id              String   @id @default("global") // 全局单例
  observations    Json     @default("[]")
  bestParams      Json?
  bestValue       Float?
  evaluationCount Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("bayesian_optimizer_state")
}

// ==================== 因果推断相关模型 ====================

/// 因果推断观测数据
model CausalObservation {
  id        String   @id @default(uuid())
  userId    String?
  features  Json     // 特征向量
  treatment Int      // 0 或 1
  outcome   Float    // [-1, 1]
  timestamp BigInt
  createdAt DateTime @default(now())

  @@index([treatment])
  @@index([timestamp])
  @@index([userId])
  @@map("causal_observations")
}
