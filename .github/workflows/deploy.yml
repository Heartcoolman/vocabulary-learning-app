name: Deploy

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

# å–æ¶ˆä¹‹å‰è¿è¡Œçš„ç›¸åŒå·¥ä½œæµ
concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: '20'
  PNPM_VERSION: '10.24.0'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ============================================
  # PR é¢„è§ˆçŽ¯å¢ƒéƒ¨ç½²
  # ============================================
  preview:
    name: Preview Deployment
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
      pull-requests: write
      deployments: write
    outputs:
      preview_url: ${{ steps.deploy-preview.outputs.preview_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Cache Turbo build
        uses: actions/cache@v4
        with:
          path: .turbo
          key: ${{ runner.os }}-turbo-preview-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-turbo-preview-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma Client
        run: pnpm prisma:generate

      - name: Build Frontend
        run: pnpm --filter @danci/frontend build
        env:
          VITE_API_URL: ${{ secrets.PREVIEW_API_URL }}
          NODE_ENV: production

      - name: Deploy to Preview Environment
        id: deploy-preview
        run: |
          # è¿™é‡Œå¯ä»¥ä½¿ç”¨ Vercelã€Netlify æˆ–å…¶ä»–é¢„è§ˆå¹³å°
          # ç¤ºä¾‹ï¼šä½¿ç”¨ Vercel éƒ¨ç½²
          # npx vercel deploy --token=${{ secrets.VERCEL_TOKEN }} --scope=${{ secrets.VERCEL_SCOPE }}

          # æˆ–è€…ä½¿ç”¨ Netlify
          # npx netlify deploy --dir=packages/frontend/dist --site=${{ secrets.NETLIFY_SITE_ID }} --auth=${{ secrets.NETLIFY_AUTH_TOKEN }}

          # ä¸´æ—¶è®¾ç½®é¢„è§ˆ URLï¼ˆå®žé™…éƒ¨ç½²æ—¶æ›¿æ¢ä¸ºçœŸå®ž URLï¼‰
          PREVIEW_URL="https://pr-${{ github.event.pull_request.number }}.preview.danci.app"
          echo "preview_url=$PREVIEW_URL" >> $GITHUB_OUTPUT
          echo "Preview URL: $PREVIEW_URL"

      - name: Comment PR with Preview URL
        uses: actions/github-script@v7
        with:
          script: |
            const previewUrl = '${{ steps.deploy-preview.outputs.preview_url }}';
            const body = `## ðŸš€ é¢„è§ˆéƒ¨ç½²å®Œæˆ

            | çŽ¯å¢ƒ | URL |
            |------|-----|
            | å‰ç«¯é¢„è§ˆ | [${previewUrl}](${previewUrl}) |

            **æäº¤:** \`${{ github.event.pull_request.head.sha }}\`
            **åˆ†æ”¯:** \`${{ github.head_ref }}\`

            ---
            _æ­¤é¢„è§ˆå°†åœ¨ PR åˆå¹¶æˆ–å…³é—­åŽè‡ªåŠ¨æ¸…ç†_`;

            // æŸ¥æ‰¾çŽ°æœ‰çš„é¢„è§ˆè¯„è®º
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('é¢„è§ˆéƒ¨ç½²å®Œæˆ')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

  # ============================================
  # æ¸…ç†é¢„è§ˆçŽ¯å¢ƒ
  # ============================================
  cleanup-preview:
    name: Cleanup Preview
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    steps:
      - name: Cleanup Preview Deployment
        run: |
          echo "Cleaning up preview deployment for PR #${{ github.event.pull_request.number }}"
          # æ·»åŠ æ¸…ç†é€»è¾‘ï¼Œä¾‹å¦‚åˆ é™¤ Vercel/Netlify éƒ¨ç½²
          # vercel remove pr-${{ github.event.pull_request.number }}.preview.danci.app --token=${{ secrets.VERCEL_TOKEN }} --yes

  # ============================================
  # ç”Ÿäº§çŽ¯å¢ƒéƒ¨ç½²
  # ============================================
  production:
    name: Production Deployment
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://danci.app
    permissions:
      contents: read
      packages: write
      deployments: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Cache Turbo build
        uses: actions/cache@v4
        with:
          path: .turbo
          key: ${{ runner.os }}-turbo-prod-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-turbo-prod-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma Client
        run: pnpm prisma:generate

      - name: Build all packages
        run: pnpm build
        env:
          VITE_API_URL: ${{ secrets.PRODUCTION_API_URL }}
          NODE_ENV: production

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata for Backend Docker
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend
          tags: |
            type=sha,prefix=
            type=raw,value=latest,enable={{is_default_branch}}
            type=semver,pattern={{version}}

      - name: Build and push Backend Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/backend/Dockerfile
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_VERSION=${{ env.NODE_VERSION }}

      - name: Extract metadata for Frontend Docker
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend
          tags: |
            type=sha,prefix=
            type=raw,value=latest,enable={{is_default_branch}}
            type=semver,pattern={{version}}

      - name: Build and push Frontend Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/frontend/Dockerfile
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_VERSION=${{ env.NODE_VERSION }}

      # éƒ¨ç½²åˆ°æœåŠ¡å™¨ï¼ˆä½¿ç”¨ SSH æˆ–å…¶ä»–éƒ¨ç½²æ–¹å¼ï¼‰
      - name: Deploy to Production Server
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }}
        run: |
          echo "Deploying to production..."
          # ç¤ºä¾‹ï¼šä½¿ç”¨ SSH éƒ¨ç½²
          # mkdir -p ~/.ssh
          # echo "$DEPLOY_KEY" > ~/.ssh/deploy_key
          # chmod 600 ~/.ssh/deploy_key
          # ssh -o StrictHostKeyChecking=no -i ~/.ssh/deploy_key $DEPLOY_USER@$DEPLOY_HOST << 'EOF'
          #   cd /opt/danci
          #   docker-compose pull
          #   docker-compose up -d
          #   docker system prune -f
          # EOF

      - name: Create GitHub Deployment
        uses: actions/github-script@v7
        with:
          script: |
            const { data: deployment } = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              auto_merge: false,
              required_contexts: [],
              description: `Production deployment for ${context.sha.substring(0, 7)}`
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.id,
              state: 'success',
              environment_url: 'https://danci.app',
              description: 'Deployment completed successfully'
            });

  # ============================================
  # æ•°æ®åº“è¿ç§»
  # ============================================
  database-migration:
    name: Database Migration
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: production
    environment:
      name: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma Client
        run: pnpm prisma:generate

      - name: Run database migrations
        run: pnpm --filter @danci/backend exec prisma migrate deploy
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

  # ============================================
  # éƒ¨ç½²é€šçŸ¥
  # ============================================
  notify:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [production, database-migration]
    if: always() && github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Send Deployment Notification
        run: |
          STATUS="success"
          if [ "${{ needs.production.result }}" == "failure" ] || [ "${{ needs.database-migration.result }}" == "failure" ]; then
            STATUS="failure"
          fi

          echo "Deployment status: $STATUS"

          # å‘é€é€šçŸ¥åˆ° Slack/Discord/é£žä¹¦ç­‰
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"Production deployment '$STATUS' for commit ${{ github.sha }}"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create Release Tag (on success)
        if: needs.production.result == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const date = new Date().toISOString().split('T')[0].replace(/-/g, '');
            const shortSha = context.sha.substring(0, 7);
            const tagName = `deploy-${date}-${shortSha}`;

            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/tags/${tagName}`,
                sha: context.sha
              });
              console.log(`Created tag: ${tagName}`);
            } catch (error) {
              console.log(`Tag might already exist: ${error.message}`);
            }
